Односвязный список - это коллекция, где есть начальный элемент head, который указывает на
следующий элемент списка. Каждый элемент списка хранит в себе данные и указывает на следующий элемент
списка. Конец любого односвязного списка - NULL.

Двусвязный список - есть два элемента к которым можно получить сразу доступ это head и tail. head
имеет указатель на следующий элемент и на NULL, а tail на предыщий и на NULL. Каждый элемент
двусвязного списка хранит в себе данные, указатель на следующий элемент и на предыдущий элемент
списка.

Списки очень эффективны в добавлении и удалении элементов в отличии от массива, т.к. каждый элемент
может хранится в произвольном месте памяти, в то время как массив должен выделять для всех элементов
место в памяти неразрывно. При добавлении элемента в массив нам надо удалять весь прошлый массив и 
выделять место под новый массив.
Массивы крайне эффективны в получении доступа к элементам т.к. их скорость всегда моментальна. А вот
чтобы двусвязному списку добраться до элемента в середине надо перейти по указателям половины
списка, чтобы получить данные элемента
Двусвязные списки более тяжёлые и их применение не всегда обязательно.

Бинарное дерево - это упорядоченная структура данных, которая сортирует их следующим образом:
У нас есть значение 50 и нам надо поместить значение 25, значит мы помещаем его влево.
Нам надо поместь значение 75, тогда помещаем его вправо. И так дальше. 
Уже для помещения элементов к примеру 100 мы сначала посмотрим на 50 элемент, слева мы не 
можем поместить т.к. 50 меньше 100, а справа можем. Дальше справа у нас хранится 75 элемент
100 больше 75 значит помещаем справа.
Каждый элемент бинарное дерево хранит в себе данные и указатель на левый и правый элементы.
Элементы элементы наследники - потомки, элементы от которых идут наследники - предки этих
наследников.
Эффективно для поиска элементов, эффективнее чем списки и двусвязные списки и относительно
эффективно добавление элементов. Это всё зависит от ситуации.
Не всегда бинарное дерево является упорядоченным. Простое бинарное дерево это ветвление,
где каждый элемент хранит в себе данные и указатели на левый и правый элементы.

Стек - по факту магазин, т.е. элементы добавляются так, что первый элемент снизу, а последний сверху.
Первым достаётся последний, а последним достаётся первый. Доступ есть только к последнему элементу.

Очередь - очередь элементов. Просто очередь. Доступ только к первому пришедшему, но добавление
в конец элементов.

Очередь с приоритетом - очередь, где есть два варианта обработки элементов:
Приоритет с сортировкой перед помещением в очередь - мы смотрим на приоритет элемента и добавляем
его к элементам с таким же приоритетам по правилу очереди в конец элементов данного приоритета.
Если элементов с таким приоритетом ещё нет то он добавляется за тем приоритетом, который идёт выше него.

Приоритет с исключением - мы исключаем элементы в очереди в зависимости от их приоритета не сортируя
их перед добавлением в эту очередь. Нам надо к примеру достать элемент, тогда мы смотрим где находится
элемент с наивысшим приоритетом и самым первым пришедшим среди элементов данного приоритета и его достаём.

Кольцевая очередь - элементы после их изъятия идут в конец очереди снова.

Дек - это двусторонняя очередь (можно добавлять и убирать элементы с обоих концов дека). Доступ есть
только к крайним элементам дека.

Дек в C++ (библотека STL) - это двусвязный список массивов. Но в новых стандартах это массив указателей
на блоки данных.
